// 记录的keyid,视频的标题,更新时间,播放时间点,视频的总时长,付费标记
var fns = require('@tencent/fns')
var Cookie = require('@tencent/txmv-core/util/cookie')
var Cover = require('./lib/Cover')
var report = require('./lib/report')
var request = require('./lib/request')
var tools = require('./lib/tools')
var Storage = require('./lib/storage')

var cover_prefix = 'ten_video_history'
var ten_video_history_uin = 'ten_video_history_uin'
var RSP = '|'
var VSP = ','
var CVSP = '_'
var MAX_HISTORY = 100 //每个用户最多能存100条记录
var FREQUENCY = 120000 //直接控制2分钟才能上传
var COUNT = FREQUENCY //刚开始的时候把以前没有上报的记录上报完
var INTERVAL_TIME = 3600000 //同一个用户，全量请求后，1小时内不准再全量请求
var lockReport = false //在上报的时候，要锁住
function noop() { }

function getUni() {
  if (Cookie.get('main_login') === 'wx') {
    var vuserid = Cookie.get('vuserid');
    if (vuserid && vuserid.length > 0) {
      return parseInt(vuserid, 10);
    } else {
      return 0;
    }
  }
  var space = /^\s*|\s*$/g
  var skey = Cookie.get('skey') || ''
  var lskey = Cookie.get('lskey') || ''
  skey = skey.replace(space, '')
  lskey = lskey.replace(space, '')
  if (!(skey || lskey)) {
    return 0
  }
  var uin = parseInt(Cookie.get('uin').replace(/^o0*/g, ''), 10);
  if (!uin || uin <= 10000) {
    uin = parseInt(Cookie.get('luin').replace(/^o0*/g, ''), 10);
    if (!uin || uin <= 10000) {
      return 0;
    }
  }
  return uin;
}

function getUnicode() {
  var suffix = getUni()
  return suffix ? (cover_prefix + suffix) : cover_prefix
}

function formate(cid, vid) {
  cid = cid || ''
  vid = vid || ''
  return cid + CVSP + vid
}

function parseCover(value, cid_vid) {
  var res = [];
  value = value.split(RSP)
  fns.forEach(value, function (item) {
    if (~item.indexOf(cid_vid)) {
      item = item.split(VSP)
      res.push(new Cover(item))
    }
  })
  return res
}

function _getNologinSyncData(cid_vid) {
    // 由未登录切换到登录时，要处理下用户未登录之前的数据
    var res = {}, temp
    var noLoginLocalData = Storage.get(cover_prefix) || ''
    
    if (noLoginLocalData) {
      temp = parseCover(noLoginLocalData, cid_vid) || []
      res = cid_vid.length > 2 ? (temp[0] || {}) : formatToMap(temp)
    }
    return res || {}
}

function _getSync(cid, vid) {
  var cid_vid = formate(cid, vid)
  var key = getUnicode()
  var value = Storage.get(key) || ''
  var res = {}, temp;
  
  if (value) {
    temp = parseCover(value, cid_vid)
    res = cid_vid.length > 2 ? (temp[0] || {}) : formatToMap(temp)
  }

  // 如果用户本地记录没有，那么获取本地未登录的记录
  if (!res || !res.keyid) {
    res = _getNologinSyncData(cid_vid)
  }

  return res
}

function save(cover) {
  var key = getUnicode()
  var value = Storage.get(key) || ''
  var valueArr = value.split(RSP)
  var len = valueArr.length,
    i,
    item;
  var cid = cover.cid || undefined,
    vid = cover.vid || undefined;
  if (value.indexOf(cid) > -1 || value.indexOf(vid) > -1) {
    //表示原来的记录里面有该cid，vid的记录
    for (i = len - 1; i >= 0; i--) {
      item = valueArr[i].split(VSP)
      if (item[0].indexOf(cid) > -1 || item[0].indexOf(vid) > -1) {
        valueArr.splice(i, 1)
        //cover.date = +new Date() //保存的时间
        // cover = fns.extend(new Cover(item), cover)   //还是完全摈弃原来的信息吧
        valueArr.unshift(new Cover(cover).toString())
        break
      }
    }
  } else {
    //表示原来的记录里面没有
    if (len >= MAX_HISTORY) {
      valueArr.splice(len - 1, 1)
    }
    valueArr.unshift(new Cover(cover).toString())
  }
  Storage.set(key, valueArr.join(RSP))
}

function isAllowedReport() {
  var temp = (+new Date()) - COUNT
  return temp > FREQUENCY
}

function _set(cover, flush) {
  save(cover)
  var key = getUnicode()
  if ((flush || isAllowedReport()) && !lockReport && key !== cover_prefix) {
    //说明要上报了
    COUNT = +new Date()
    lockReport = true
    var reportList = getReportList()
    if (reportList.length > 0) {
      if (reportList.length > 1) {
        report.batchReport({
          list: reportList.join(RSP)
        }, handle)
      } else {
        var data = reportList[0].split('+')

        report.reportOne({
          keyid: data[0],
          time: data[1],
          date: data[2],
          hd: data[3],
          typeid: data[4]
        }, handle)
      }
      // safari 无痕模式下，不支持localStorage，立即上报吧	
    } else if (Storage.safariPrivateMode) {
      var c = new Cover(cover);
      report.reportOne({
        keyid: c.keyid,
        time: c.time,
        date: parseInt(c.date / 1000),
        hd: c.hd,
        typeid: c.typeid
      }, handle)
    }
  }

  function handle(err) {
    lockReport = false
    if (!err) {
      updateLocal(reportList) //更新serverDate,删除未登陆的用户的播放记录
    }
  }
  return true
}

function updateLocal(reportList) {
  Storage.remove(cover_prefix) //上报后要删除本地的没有用户态的播放记录
  var timeStmp = +new Date()
  var index, later, target;
  var key = getUnicode()
  var value = Storage.get(key) || ''
  fns.forEach(reportList, function (item) {
    item = item.split('+')[0]
    index = value.indexOf(item)
    if (index > -1) {
      later = value.indexOf(RSP, index)
      target = value.slice(index, later)
      target = target.split(VSP)
      target[8] = timeStmp //target[8]表示更新到服务器的时间
      value = value.slice(0, index) + target.join(VSP) + value.slice(later)
    }
  })
  Storage.set(key, value)
}

function getNecessaryData(opt) {
  //keyid 观看时间 用户在什么时间观看的  清晰度 typeid 
  return [opt[0], opt[3], parseInt(opt[2] / 1000), opt[9], opt[6]].join('+');
}

function getReportList() {
  var reportList = []
  var key = getUnicode()
  var value;
  value = Storage.get(cover_prefix) || '' //拿到没有登陆用户的播放记录，这个记录要算在登陆用户的历史记录里面
  if (key != cover_prefix) {
    value += RSP + (Storage.get(key) || '')
  }
  value = value.split(RSP)
  fns.forEach(value, function (item) {
    item = item.split(VSP)
    if (item[2] >= item[8]) { //本地更新时间大于服务器上报时间
      reportList.push(getNecessaryData(item))
    }
  })

  return reportList
}

/**
 *把从服务器拿到的数据同步到本地
 **/
function updateStorage(listCover) {
  var valueArr = []
  var newValue = []
  var repeated = false
  // var remoteD, localD;
  var key = getUnicode()
  // if (uni[key]) { //如果本地已经全量拿过一次了，就不需要再更新本地了，因为这次拿到的要么是本地就有的,或者更新的,要么是记录的日期比前老
  // 	return
  // }
  var value = Storage.get(key) || ''
  value = parseCover(value, '_')
  var vid, cid, cid_vid;
  // console.time("更新本地")
  fns.forEach(value, function (item) {
    repeated = false
    fns.some(listCover, function (l) { //返回true，结束循环
      cid_vid = item.keyid.split(CVSP)
      cid = cid_vid[0] || undefined
      vid = cid_vid[1] || undefined
      if (l.keyid.indexOf(cid) > -1 || l.keyid.indexOf(vid) > -1) {
        // remoteD = parseInt(l.date)
        // localD = parseInt(item.date)
        // if (remoteD > localD) { //拉取的数据比本地的数据新
        // 	item.time = l.time || item.time
        // 	item.episode = l.episode || item.episode
        // 	item.hd = l.hd || item.hd
        // }
        if (parseInt(l.date) < parseInt(item.date)) { //本地的数据比拉取的数据新
          if (l.keyid === item.keyid) {
            l.time = item.time || l.time
            l.episode = item.episode || l.episode
            l.hd = item.hd || l.hd
            l.date = item.date
            l.serverDate = item.serverDate
          } else { //说明只是cid_vid的部分相等,在cid相同而vid不同的情况
            fns.extend(l, item)
          }
        }
        // item.date = l.date||item.date
        // item.title = l.title||item.title
        // item.typeid = l.typeid||item.typeid 
        // item.ispay = l.ispay||item.ispay
        // item.dur = l.dur||item.dur
        repeated = true
        return true //跳出当前循环
      }
    })
    if (!repeated) {
      newValue.push(item)
    }
  })
  // console.timeEnd('更新本地')
  // if (!cache) { //如果不是全量的话,就不需要把拿到的数据和原来的数据merge
  // 	fns.forEach(value, function(item) {
  // 		valueArr.push(item.toString())
  // 	})
  // } else {

  listCover = listCover.concat(newValue)
  // console.time('根据date字段排序')
  //listCover = tools.quickSort(listCover, 'date') //对listCover中的对象的date进行快速排序,O(nlogn)
  listCover.sort(tools.by('date'))
  // console.timeEnd('根据date字段排序')
  listCover.splice(MAX_HISTORY, listCover.length - MAX_HISTORY)
  fns.forEach(listCover, function (item) {
    valueArr.push(item.toString())
  })
  // }
  Storage.set(key, valueArr.join(RSP))
}


function _get(cvObj, cb) {
  var keyid = formate(cvObj.cid, cvObj.vid)
  var key = getUnicode()
  if (key === cover_prefix) {
    cb('用户没有登陆')
    return
  }
  var uni = getUniObject()
  var options = {}
  var cache = true
  if (keyid.length > 2) {
    cache = false
  }
  if (fns.type(cvObj) == 'array') {
    cache = false
    keyid = cvObj.join(RSP)
  }
  if (cvObj.cur) {
    options.cur = cvObj.cur
    cache = false
  }
  if (cvObj.pn) {
    options.pn = cvObj.pn
    cache = false
  }
  if (cache && !allowRequest()) {
    cb(null, _getSync()) //不发起请求，直接从本地拿
    return
  }

  _requestHistory()

  function _requestHistory() {
    request.getHistory(keyid, _cbHandler, options)
  }

  // function _getBatchHistory() {
  // 	request.batchHistory(cvObj, _cbHandler)
  // }

  function _cbHandler(err, res) {
    if (err) {
      cb(err)
    } else {
      var coverList = toCover(res)
      var resData;
      if (cvObj.cid || cvObj.vid) { //返回一个Cover对象
        resData = coverList[0] || {}
      } else { //返回一个{keyid:Cover}
        resData = formatToMap(coverList || [])
      }
      cb(null, resData)
      if (Storage.support) {
        setTimeout(function () {
          updateStorage(toCover(res, true)) //防止updateStorage更改coverList，影响用户
          if (cache) {
            uni[key] = +new Date()
            Storage.setJSON(ten_video_history_uin, uni)
          }
        })
      }
    }
  }

  function allowRequest() {
    if (!Storage.support) return false;

    var lastTime = parseInt(uni[key]) || 0
    var interval = +new Date() - lastTime
    if (interval > INTERVAL_TIME) {
      delete uni[key]
      Storage.setJSON(ten_video_history_uin, uni)
      return true
    } else {
      return false
    }
  }
}

function getUniObject() {
  if (!Storage.support) return {};

  var uni = Storage.get(ten_video_history_uin)
  uni = uni || '{}'
  uni = JSON.parse(uni)
  return uni
}

function formatToMap(coverList) {
  var map = {}
  for (var i = 0, len = coverList.length; i < len; i++) {
    map[coverList[i].keyid] = coverList[i]
  }
  return map
}

function toCover(list, ignore) {
  var res = [];
  ignore ? fns.forEach(list, function (l) {
    res.push(new Cover(l))
  }) :
    fns.forEach(list, function (l) {
      l.dur = l.tl
      l.date = l.date * 1000 //拿到的观看时间是秒数，得变成毫秒
      l.serverDate = l.date + 1000
      res.push(new Cover(l))
    })
  return res
}

function isLegal(id, num) {
  num = num || 11
  var reg = new RegExp('^[a-zA-Z0-9]{' + num + '}$')
  return reg.test(id)
}

var historyManage = {
	/**
	 *以对象方式传入cid,vid，可以从远程拿取该用户的cid_vid的历史记录
	 *以数组方式传入cid_vid，可以从远程批量拿取指定cid_vid的历史记录
	 *不传cid，vid，传入当前页码cur，每次拿取的数量pn，可以批量获取历史记录
	 *如果只有cb表示获取该用户的所有播放历史记录，会同步到本地
	 *cb是回条函数数据，参数err,data
	 **/
  get: function (cvObj, cb) {
    if (typeof cvObj === 'function') {
      cb = cvObj
      cvObj = {}
    }
    if (fns.type(cvObj) === 'array' && cvObj.length > 10) {
      throw new Error('一次最多传入10个')
    }
    _get(cvObj, cb)
  },
	/**
	 *获取用户观看的历史记录
	 *vid,cid的意义同上
	 **/
  getSync: function (cvObj) {
    if (!Storage.support) return {};
    cvObj = cvObj || {}
    return _getSync(cvObj.cid, cvObj.vid)
  },
	/**
	 *cover是一个对象，包含Cover实例的属性
	 **/
  set: function (cover, flush) {
    if (!Storage.support) return false
    if (fns.type(cover) !== 'object') return false
    cover.time = parseInt(cover.time)
    if (!cover.vid || isNaN(cover.time)) return false
    if (!(isLegal(cover.vid, 11) || isLegal(cover.cid, 15))) return false
    cover.hd = cover.hd && parseInt(cover.hd) || 0
    cover.typeid = cover.typeid && cover.typeid.toString() || ''
    cover.title = cover.title || ''
    cover.title = cover.title.replace(/,/g,'，') // 本地存储用了英文逗号来分割，这里需要处理一下标题，简单一点直接用中文逗号替换吧
    return _set(cover, flush)
  }
}

if (!Storage.safariPrivateMode) {
  historyManage.get(noop)
}

module.exports = historyManage