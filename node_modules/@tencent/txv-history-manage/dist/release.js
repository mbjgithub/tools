/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	// 记录的keyid,视频的标题,更新时间,播放时间点,视频的总时长,付费标记
	var fns = __webpack_require__(1)
	var Cookie = __webpack_require__(2)
	var Cover = __webpack_require__(3)
	var report = __webpack_require__(4)
	var request = __webpack_require__(8)
	var tools = __webpack_require__(9)

	function noop() {}

	var isSupport = typeof window.localStorage === 'object' && (!!localStorage.getItem) //ie8的typeof function===object

	var cover_prefix = "ten_video_history"
	var ten_video_history_uin = "ten_video_history_uin"
	var RSP = '|'
	var VSP = ','
	var CVSP = '_'
	var MAX_HISTORY = 100 //每个用户最多能存100条记录
	var FREQUENCY = 120000 //直接控制2分钟才能上传
	var COUNT = FREQUENCY //刚开始的时候把以前没有上报的记录上报完
	var INTERVAL_TIME = 3600000 //同一个用户，全量请求后，1小时内不准再全量请求

	var lockReport = false //在上报的时候，要锁住


	var Storage = {
		get: noop,
		set: noop,
		remove: noop
	}

	if (isSupport) {
		fns.extend(Storage, {
			get: function(key) {
				return localStorage.getItem(key)
			},
			set: function(key, value) {
				return localStorage.setItem(key, value)
			},
			remove: function(key) {
				return localStorage.removeItem(key)
			}
		})
	}

	function getUni() {
		if (Cookie.get('main_login') === 'wx') {
			var vuserid = Cookie.get("vuserid");
			if (vuserid && vuserid.length > 0) {
				return parseInt(vuserid, 10);
			} else {
				return 0;
			}
		}
		var space = /^\s*|\s*$/g
		var skey = Cookie.get("skey") || ""
		var lskey = Cookie.get("lskey") || ""
		skey = skey.replace(space, "")
		lskey = lskey.replace(space, "")
		if (!(skey || lskey)) {
			return 0
		}
		var uin = parseInt(Cookie.get('uin').replace(/^o0*/g, ""), 10);
		if (!uin || uin <= 10000) {
			uin = parseInt(Cookie.get('luin').replace(/^o0*/g, ""), 10);
			if (!uin || uin <= 10000) {
				return 0;
			}
		}
		return uin;
	}

	function getUnicode() {
		var suffix = getUni()
		return suffix ? (cover_prefix + suffix) : cover_prefix
	}

	function formate(cid, vid) {
		cid = cid || ""
		vid = vid || ""
		return cid + CVSP + vid
	}

	function parseCover(value, cid_vid) {
		var res = [];
		value = value.split(RSP)
		fns.forEach(value, function(item) {
			if (~item.indexOf(cid_vid)) {
				item = item.split(VSP)
				res.push(new Cover(item))
			}
		})
		return res
	}


	function _getSync(cid, vid) {
		var cid_vid = formate(cid, vid)
		var key = getUnicode()
		var value = Storage.get(key) || ''
		var res, temp;
		if (value) {
			temp = parseCover(value, cid_vid)
			res = cid_vid.length > 2 ? (temp[0] || {}) :
				formatToMap(temp)
		} else {
			res = {}
		}
		return res
	}

	function save(cover) {
		var key = getUnicode()
		var value = Storage.get(key) || ""
		var valueArr = value.split(RSP)
		var len = valueArr.length,
			i,
			item;
		var cid = cover.cid || undefined,
			vid = cover.vid || undefined;
		if (~value.indexOf(cid) || ~value.indexOf(vid)) {
			//表示原来的记录里面有该cid，vid的记录
			for (i = len - 1; i >= 0; i--) {
				item = valueArr[i].split(VSP)
				if (~item[0].indexOf(cid) || ~item[0].indexOf(vid)) {
					valueArr.splice(i, 1)
						//cover.date = +new Date() //保存的时间
						// cover = fns.extend(new Cover(item), cover)   //还是完全摈弃原来的信息吧
					valueArr.unshift(new Cover(cover).toString())
					break
				}
			}
		} else {
			//表示原来的记录里面没有
			if (len >= MAX_HISTORY) {
				valueArr.splice(len - 1, 1)
			}
			valueArr.unshift(new Cover(cover).toString())
		}
		Storage.set(key, valueArr.join(RSP))
	}

	function isAllowedReport() {
		var temp = (+new Date()) - COUNT
		return temp > FREQUENCY ? true : false
	}

	function _set(cover, flush) {
		save(cover)
		var key = getUnicode()
		if ((flush || isAllowedReport()) && !lockReport && key !== cover_prefix) {
			//说明要上报了
			COUNT = +new Date()
			lockReport = true
			var reportList = getReportList()
			if (reportList.length > 0) {
				if (reportList.length > 1) {
					report.batchReport({
						list: reportList.join(RSP)
					}, handle)
				} else {
					var data = reportList[0].split('+')

					report.reportOne({
						keyid: data[0],
						time: data[1],
						date: data[2],
						hd: data[3],
						typeid: data[4]
					}, handle)
				}
			}
		}

		function handle(err, res) {
			if (err) {
				lockReport = false
			} else {
				lockReport = false
				updateLocal(reportList) //更新serverDate,删除未登陆的用户的播放记录
			}
		}
		return true
	}

	function updateLocal(reportList) {
		Storage.remove(cover_prefix) //上报后要删除本地的没有用户态的播放记录
		var timeStmp = +new Date()
		var index, later, target;
		var key = getUnicode()
		var value = Storage.get(key) || ""
		fns.forEach(reportList, function(item) {
			item = item.split('+')[0]
			index = value.indexOf(item)
			if (~index) {
				later = value.indexOf(RSP, index)
				target = value.slice(index, later)
				target = target.split(VSP)
				target[8] = timeStmp //target[8]表示更新到服务器的时间
				value = value.slice(0, index) + target.join(VSP) + value.slice(later)
			}
		})
		Storage.set(key, value)
	}

	function getReportList() {
		var reportList = []
		var key = getUnicode()
		var item, value, len;
		value = Storage.get(cover_prefix) || "" //拿到没有登陆用户的播放记录，这个记录要算在登陆用户的历史记录里面
		if (key != cover_prefix) {
			value += RSP + (Storage.get(key) || "")
		}
		value = value.split(RSP)
		fns.forEach(value, function(item) {
			item = item.split(VSP)
			if (item[2] >= item[8]) { //本地更新时间大于服务器上报时间
				reportList.push(getNecessaryData(item))
			}
		})

		function getNecessaryData(opt) {
			return [opt[0], opt[3], parseInt(opt[2] / 1000), opt[9], opt[6]].join("+");
			//keyid 观看时间 用户在什么时间观看的  清晰度 typeid 
		}
		return reportList
	}

	/**
	 *把从服务器拿到的数据同步到本地
	 **/
	function updateStorage(listCover) {
		var valueArr = []
		var newValue = []
		var repeated = false
			// var remoteD, localD;
		var key = getUnicode()
			// if (uni[key]) { //如果本地已经全量拿过一次了，就不需要再更新本地了，因为这次拿到的要么是本地就有的,或者更新的,要么是记录的日期比前老
			// 	return
			// }
		var value = Storage.get(key) || ""
		value = parseCover(value, "_")
		var vid, cid, cid_vid;
		// console.time("更新本地")
		fns.forEach(value, function(item) {
				repeated = false
				fns.some(listCover, function(l) { //返回true，结束循环
					cid_vid = item.keyid.split(CVSP)
					cid = cid_vid[0] || undefined
					vid = cid_vid[1] || undefined
					if (~l.keyid.indexOf(cid) || ~l.keyid.indexOf(vid)) {
						// remoteD = parseInt(l.date)
						// localD = parseInt(item.date)
						// if (remoteD > localD) { //拉取的数据比本地的数据新
						// 	item.time = l.time || item.time
						// 	item.episode = l.episode || item.episode
						// 	item.hd = l.hd || item.hd
						// }
						if (parseInt(l.date / 1000) < parseInt(item.date / 1000)) { //本地的数据比拉取的数据新
							if (l.keyid === item.keyid) {
								l.time = item.time || l.time
								l.episode = item.episode || l.episode
								l.hd = item.hd || l.hd
								l.date = item.date
								l.serverDate = item.serverDate
							} else { //说明只是cid_vid的部分相等,在cid相同而vid不同的情况
								fns.extend(l, item)
							}
						}
						// item.date = l.date||item.date
						// item.title = l.title||item.title
						// item.typeid = l.typeid||item.typeid 
						// item.ispay = l.ispay||item.ispay
						// item.dur = l.dur||item.dur
						repeated = true
						return true //跳出当前循环
					}
				})
				if (!repeated) {
					newValue.push(item)
				}
			})
			// console.timeEnd('更新本地')
			// if (!cache) { //如果不是全量的话,就不需要把拿到的数据和原来的数据merge
			// 	fns.forEach(value, function(item) {
			// 		valueArr.push(item.toString())
			// 	})
			// } else {

		listCover = listCover.concat(newValue)
			// console.time('根据date字段排序')
			//listCover = tools.quickSort(listCover, 'date') //对listCover中的对象的date进行快速排序,O(nlogn)
		listCover.sort(tools.by('date'))
			// console.timeEnd('根据date字段排序')
		listCover.splice(MAX_HISTORY, listCover.length - MAX_HISTORY)
		fns.forEach(listCover, function(item) {
				valueArr.push(item.toString())
			})
			// }
		Storage.set(key, valueArr.join(RSP))
	}


	function _get(cvObj, cb) {
		var keyid = formate(cvObj.cid, cvObj.vid),
			list = [];
		var key = getUnicode()
		if (key === cover_prefix) {
			cb('用户没有登陆')
			return
		}
		var uni = getUniObject()
		var options = {}
		var cache = true
		if (keyid.length > 2) {
			cache = false
		}
		if (fns.type(cvObj) == 'array') {
			cache = false
			keyid = cvObj.join(RSP)
		}
		if (cvObj.cur) {
			options.cur = cvObj.cur
			cache = false
		}
		if (cvObj.pn) {
			options.pn = cvObj.pn
			cache = false
		}
		if (cache && !allowRequest()) {
			cb(null, _getSync()) //不发起请求，直接从本地拿
			return
		}

		_requestHistory()

		function _requestHistory() {
			request.getHistory(keyid, _cbHandler, options)
		}

		// function _getBatchHistory() {
		// 	request.batchHistory(cvObj, _cbHandler)
		// }

		function _cbHandler(err, res) {
			if (err) {
				cb(err)
			} else {
				var coverList = toCover(res)
				var resData;
				if (cvObj.cid || cvObj.vid) { //返回一个Cover对象
					resData = coverList[0] || {}
				} else { //返回一个{keyid:Cover}
					resData = formatToMap(coverList || [])
				}
				cb(null, resData)
				if (isSupport) {
					setTimeout(function() {
						updateStorage(toCover(res, true)) //防止updateStorage更改coverList，影响用户
						if (cache) {
							uni[key] = +new Date()
							Storage.set(ten_video_history_uin, JSON.stringify(uni))
						}
					})
				}
			}
		}

		function allowRequest() {
			if (!isSupport) return false
			var lastTime = parseInt(uni[key]) || 0
			var interval = +new Date() - lastTime
			if (interval > INTERVAL_TIME) {
				delete uni[key]
				Storage.set(ten_video_history_uin, JSON.stringify(uni))
				return true
			} else {
				return false
			}
		}
	}

	function getUniObject() {
		if (!isSupport) return {}
		var uni = Storage.get(ten_video_history_uin)
		uni = uni || "{}"
		uni = JSON.parse(uni)
		return uni
	}

	function formatToMap(coverList) {
		var map = {}
		for (var i = 0, len = coverList.length; i < len; i++) {
			map[coverList[i].keyid] = coverList[i]
		}
		return map
	}

	function toCover(list, ignore) {
		var res = [];
		ignore ? fns.forEach(list, function(l) {
				res.push(new Cover(l))
			}) :
			fns.forEach(list, function(l) {
				l.dur = l.tl
				l.date = l.date * 1000 //拿到的观看时间是秒数，得变成毫秒
				l.serverDate = l.date + 1000
				res.push(new Cover(l))
			})
		return res
	}

	function isLegal(id, num) {
		num = num || 11
		var reg = new RegExp("^[a-zA-Z0-9]{" + num + "}$")
		return reg.test(id)
	}

	var historyManage = {
		/**
		 *以对象方式传入cid,vid，可以从远程拿取该用户的cid_vid的历史记录
		 *以数组方式传入cid_vid，可以从远程批量拿取指定cid_vid的历史记录
		 *不传cid，vid，传入当前页码cur，每次拿取的数量pn，可以批量获取历史记录
		 *如果只有cb表示获取该用户的所有播放历史记录，会同步到本地
		 *cb是回条函数数据，参数err,data
		 **/
		get: function(cvObj, cb) {
			if (typeof cvObj === 'function') {
				cb = cvObj
				cvObj = {}
			}
			if (fns.type(cvObj) === 'array' && cvObj.length > 10) {
				throw new Error("一次最多传入10个")
			}
			_get(cvObj, cb)
		},
		/**
		 *获取用户观看的历史记录
		 *vid,cid的意义同上
		 **/
		getSync: function(cvObj) {
			if (!isSupport) return {}
			cvObj = cvObj || {}
			return _getSync(cvObj.cid, cvObj.vid)
		},
		/**
		 *cover是一个对象，包含Cover实例的属性
		 **/
		set: function(cover, flush) {
			if (!isSupport) return false
			if (fns.type(cover) !== 'object') return false
			cover.time = parseInt(cover.time)
			if (!cover.vid || isNaN(cover.time)) return false
			if (!(isLegal(cover.vid, 11) || isLegal(cover.cid, 15))) return false
			cover.hd = cover.hd && parseInt(cover.hd) || 0
			cover.typeid = cover.typeid && cover.typeid.toString() || ""
			return _set(cover, flush)
		}
	}

	historyManage.get(noop)

	module.exports = historyManage

/***/ }),
/* 1 */
/***/ (function(module, exports) {

	'use strict'

	var undef = void(0)
	function hasOwn (obj, prop) {
	    return obj && obj.hasOwnProperty && obj.hasOwnProperty(prop)
	}
	function _nextTick() {
	    var ctx = this
	    return function () {
	        setTimeout.apply(ctx, arguments)
	    }
	}
	var fns = {
	    escape: function (markup) {
	        if (!markup) return '';
	        return String(markup)
	            .replace(/&/g, '&amp;')
	            .replace(/</g, '&lt;')
	            .replace(/>/g, '&gt;')
	            .replace(/'/g, '&#39;')
	            .replace(/"/g, '&quot;');
	    },
	    type: function(obj) {
	        if (obj === null) return 'null'
	        else if (obj === undef) return 'undefined'
	        var m = /\[object (\w+)\]/.exec(Object.prototype.toString.call(obj))
	        return m ? m[1].toLowerCase() : ''
	    },
	    keys: function (obj) {
	        var keys = []
	        if (!obj) return keys
	        if (Object.keys) return Object.keys(obj)
	        this.objEach(obj, function (key) {
	            keys.push(key)
	        })
	        return keys
	    },
	    bind: function (fn, ctx) {
	        if (fn.bind) return fn.bind(ctx)
	        return function () {
	            return fn.apply(ctx, arguments)
	        }
	    },
	    extend: function(obj) {
	        if (this.type(obj) != 'object' && this.type(obj) != 'function') return obj;
	        var source, prop;
	        for (var i = 1, length = arguments.length; i < length; i++) {
	            source = arguments[i];
	            for (prop in source) {
	                if (hasOwn(source, prop)) {
	                    obj[prop] = source[prop];
	                }
	            }
	        }
	        return obj;
	    },
	    trim: function (str) {
	        if (str.trim) return str.trim()
	        else {
	            return str.replace(/^\s+|\s+$/gm, '')
	        }
	    },
	    indexOf: function (arr, tar) {
	        if (arr.indexOf) return arr.indexOf(tar)
	        else {
	            var i = -1
	            fns.some(arr, function (item, index) {
	                if (item === tar) {
	                    i = index
	                    return true
	                }
	            })
	            return i
	        }
	    },
	    forEach: function (arr, fn) {
	        if (arr.forEach) return arr.forEach(fn)
	        else {
	            var len = arr.length
	            for (var i = 0 ; i < len; i++) {
	                fn(arr[i], i)
	            }
	        }
	        return arr
	    },
	    some: function (arr, fn) {
	        if (arr.some) return arr.some(fn)
	        else {
	            var len = arr.length
	            var r = false
	            for (var i = 0 ; i < len; i++) {
	                if (fn(arr[i], i)) {
	                    r = true
	                    break
	                }
	            }
	            return r
	        }
	    },
	    map: function (arr, fn) {
	        if (arr.map) return arr.map(fn)
	        else {
	            var len = arr.length
	            var next = []
	            for (var i = 0 ; i < len; i++) {
	                next.push(fn(arr[i], i))
	            }
	            return next
	        }
	    },
	    objEach: function (obj, fn) {
	        if (!obj) return
	        for(var key in obj) {
	            if (hasOwn(obj, key)) {
	                if(fn(key, obj[key]) === false) break
	            }
	        }
	    },
	    reduce: function (arr, cb/*initValue*/) {
	        if (fns.type(cb) != 'function') throw new TypeError('Array.prototype.reduce callback must be a function')

	        var length = arr.length
	        if (length === 0 && arguments.length === 2) {
	            throw new TypeError('reduce of empty array with no initial value');
	        }
	        var result;
	        var i = 0
	        if (arguments.length >= 3) {
	            result = arguments[2]
	        } else {
	            do {
	                if (i in arr) {
	                    result = arr[i++];
	                    break;
	                }
	                // if array contains no values, no initial value to return
	                if (++i >= length) {
	                    throw new TypeError('reduceRight of empty array with no initial value');
	                }
	            } while (true);
	        }
	        for (; i < length; i++) {
	            result = cb(result, arr[i], i, arr);
	        }
	        return result;
	    },
	    filter: function(arr, fn, context) {
	        if (arr.filter) return arr.filter(fn)
	        else {
	            var len = arr.length
	            var res = []
	            for(var i = 0; i < len; i++) {
	                var val = arr[i]
	                if(fn.call(context, val, i, arr)) {
	                    res.push(val)
	                }
	            }
	            return res
	        }
	    },
	    nextTick: _nextTick(),
	    /**
	     * Lock function before lock release
	     */
	    lock: function lock(fn) {
	        var pending
	        return function () {
	            if (pending) return
	            pending = true
	            var args = [].slice.call(arguments, 0)
	            args.unshift(function () {
	                pending = false
	            })
	            fn.apply(this, args)
	        }
	    },
	    /**
	     * Queue when pending, execute one by one
	     * @param {Function} fn executed function
	     * @param {Number} capacity Allow run how much parall task at once
	     * @async
	     */
	    queue: function queue(fn, capacity) {
	        capacity = capacity || 1
	        var callbacks = []
	        var remains = capacity
	        function next() {
	            var item = callbacks.shift()
	            if (!item) {
	                remains = capacity
	                return
	            }
	            remains--
	            var fn = item[0]
	            var ctx = item[1]
	            var args = item[2]
	            args.unshift(function () {
	                // once task is done, remains increasing
	                remains ++
	                // then check or call next task
	                next.apply(this, arguments)
	            })
	            fns.nextTick(function () {
	                return fn.apply(ctx, args)
	            })
	        }
	        return function () {
	            callbacks.push([fn, this, [].slice.call(arguments, 0)])
	            if (!remains) return
	            return next()
	        }
	    },
	    /**
	     * Queue and wait for the same result
	     * @param {Function} delegate method
	     * @return {Function} the method receive a callback function
	     */
	    delegator: function (fn) {
	        var pending
	        var queue = []
	        return function (cb) {
	            if (pending) return queue.push(cb)
	            pending = true
	            fn.call(this, function () {
	                pending = false
	                var ctx = this
	                var args = arguments
	                cb && cb.apply(ctx, args)
	                fns.forEach(queue, function (f) {
	                    f && f.apply(ctx, args)
	                })
	            })
	        }
	    },
	    /**
	     * Call only once
	     */
	    once: function (cb/*[, ctx]*/) {
	        var args = arguments
	        var called
	        return function () {
	            if (called || !cb) return
	            called = true
	            return cb.apply(args.length >=2 ? args[1] : null, arguments)
	        }
	    },
	    /**
	     * Version compare
	     * @param  {String} v1 6.5.5.200
	     * @param  {String} v2 6.5.6    缺位默认补0
	     * if (v2 > v1) return 1
	     * else (v2 == v1) retun 0
	     * else return -1
	     */
	    verCompare: function (v1, v2) {
	        if (v1 === v2) return 0

	        v1 = v1.split('.')
	        v2 = v2.split('.')

	        var len = v1.length >= v2.length ? v1.length : v2.length
	        var i = 0
	        var r = 0

	        while(len--) {
	            var c1 = Number(v1[i] || 0)
	            var c2 = Number(v2[i++] || 0)

	            if (c2 > c1) {
	                return 1
	            } else if (c2 < c1) {
	                return -1
	            }
	        }
	        return r
	    } 
	}

	module.exports = fns


/***/ }),
/* 2 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = {
		/**
		 * 设置一个cookie
		 * @param {String}
		 *          name cookie名称
		 * @param {String}
		 *          value cookie值
		 * @param {String}
		 *          domain 所在域名 默认为window.location.host的值
		 * @param {String}
		 *          path 所在路径 默认为是"\"
		 * @param {Number}
		 *          hour 存活时间，单位:小时
		 * @return {Boolean} 是否成功
		 */
		set: function (name, value, domain, path, hour) {
			if (hour) {
				var today = new Date();
				var expire = new Date();
				expire.setTime(today.getTime() + 3600000 * hour);
			}
			document.cookie = name + "=" + value + "; " + (hour ? ("expires=" + expire.toGMTString() + "; ") : "") + (path ? ("path=" + path + "; ") : "path=/; ") + (domain ? ("domain=" + domain + ";") : ("domain=" + window.location.host + ";"));
			return true;
		},

		/**
		 * 获取指定名称的cookie值
		 *
		 * @param {String}
		 *          name cookie名称
		 * @return {String} 获取到的cookie值
		 */
		get: function (name, cookies) {
			var r = new RegExp("(?:^|;+|\\s+)" + name + "=([^;]*)");
			var m = (cookies || document.cookie).match(r);
			return (!m ? "" : m[1]);
		},

		/**
		 * 删除指定cookie,复写为过期
		 *
		 * @param {String}
		 *          name cookie名称
		 * @param {String}
		 *          domain 所在域 默认为 window.location.host的值
		 * @param {String}
		 *          path 所在路径 默认为是"\"
		 */
		del: function (name, domain, path) {
			var exp = new Date();
			exp.setTime(exp.getTime() - 1);
			document.cookie = name + "=; expires=" + exp.toGMTString() + ";" + (path ? ("path=" + path + "; ") : "path=/; ") + (domain ? ("domain=" + domain + ";") : ("domain=" + window.location.host + ";"));
		}
	};

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	//记录的keyid,视频的标题,更新时间,播放时间点,视频的总时长,付费标记,视频大分类,当前观看到的集数,服务器更新时间
	function Cover(obj) {
		if (obj.title || obj.vtit) {
			obj.title = (obj.title || "") + " " + (obj.vtit || "")
		}
		this.title = obj.title || obj[1] || ""   //当前视频的标题
		this.time = obj.time || obj[3] || 0 //当前观看的时间
		this.dur = obj.dur || obj.tl || obj[4] || 0 //视频总时间
		this.episode = obj.episode || obj[7] || 0 //当前观看到的集数
		this.ispay = obj.ispay || obj[5] || "" //是否是付费视频
		this.keyid = obj[0] || obj.keyid || ((obj.cid || "") + "_" + (obj.vid || "")) //cid_vid的组合
		this.typeid = obj.typeid || obj.ctypeid || obj[6] //视频大分类
		this.date = obj.date || obj[2] || (new Date().getTime()) //本地记录更新时间
		this.serverDate = obj.serverDate || obj[8] || 0 //服务器的更新时间,用于和本地更新时间比较，判断要不要上传 
		this.hd = obj.hd || obj[9] || 0
	}

	Cover.prototype.toString = function() {
		return [this.keyid, this.title, this.date, this.time, this.dur, this.ispay, this.typeid, this.episode, this.serverDate, this.hd].join(',')
	}

	module.exports = Cover

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	var consts = __webpack_require__(5)
	var fns=__webpack_require__(1)
	var jsonp=__webpack_require__(6)

	var URL=consts.api.myviewreport


	module.exports = {
	    reportOne: reportOne,
	    batchReport: batchReport
	}


	function reportOne(data,cb){
	    data=fns.extend(data, {
	            plat: 2,
	            pver: 3, //cgi第3个版本,
	            rf: 'v', //v:v.qq.com.hlw :film.qq.com
	            t: consts.rParamT.ONEREPORT
	        })

	    jsonp(URL,data,function(err,res){
	        err?cb('上报失败'):cb(null,res)
	    })
	}

	function batchReport(data,cb){
	    data=fns.extend({
	            pn: 1,
	            list: "", //split by "|"
	            rf: "v"
	        }, data, {
	            t: consts.rParamT.BATCHREPORT,
	            cur: 1,   //当前页码
	            simp: 1,
	            plat: 2, // 平台参数
	            pver: 3  //第3个版本
	        })
	    jsonp(URL,data,function(err,res){
	        err?cb('上报失败'):cb(null,res)
	    })
	}

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	module.exports = {
	    api: {
	        ///**
	        // * 我的观看记录,单个和批量的观看记录，都指定了cid_vid的
	        // */
	        specifyview: '//node.video.qq.com/x/api/specify_history',
	        /**
	         * 观看上报
	         */
	        myviewreport: '//like.video.qq.com/fcgi-bin/myviewreport?otype=json',
	        /**
	        *通过cgi去全量拉取数据,或者提供翻页和翻页条数
	        */
	        batchview:'//node.video.qq.com/x/api/batch_history'
	    },
	    /**
	     * RCGI.VIDEO.QQ.COM
	     */
	    rParamT: {
	        /**
	         * 上报1条观看记录,（播放中上报）
	         * @type Number
	         */
	        ONEREPORT: 3, //添加我的观看(post)
	        /**
	         * 上报一批观看记录
	         * @type Number
	         */
	        BATCHREPORT: 4   //批量添加我的观看(post)
	        /**
	         * 查1个id的上次观看情况(主要播放器用)
	         * @type Number
	         */
	        // ONEINFO: 7, //获取一条历史记录信息
	        // BATCHINFO: 1, //获取多条历史记录信息
	        // PN: 10, //批量获取用户观看记录，每次的条数     
	        // CUR: 1, //批量获取用户观看记录，当前页码
	        // ALLINFO:6,  //获取用户的所有历史记录 
	        // BATCHREQUESTINFO:8//可以拿取指定一些keyid的历史记录
	        
	    }
	}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * jspnp
	 * @version 1.0.1
	 * @author switer
	 * @github https://github.com/switer/jsonp
	 */
	'use strict';

	var fns = __webpack_require__(1)
	var TURL = __webpack_require__(7)
	var _ns = '_jsonp'
	// callback name, 为什么叫 pn ？忘记了
	var _pn = 'callback'
	var _id = 0
	var _t = 20*1000 // 超时时间
	var _beforeHooks = [] // hook before send

	function noop () {}
	function uuid() {
	    return Math.floor((1 + Math.random()) * 0x10000)
	      .toString(16)
	      .substring(1);
	}
	function remove(el) {
	    if (el && el.parentNode) {
	        el.parentNode.removeChild(el)
	    }
	}

	function jsonp (url/*[, data]*/, cb, options) {
	var args = arguments
	return PWrap(function (resolve, reject) {
	    var data
	    // 参数右移
	    if (typeof cb == 'object') {
	        data = cb
	        cb = options
	        options = args[3]
	    }
	    data = data || {}
	    options = options || {}
	    cb = cb || noop
	    if (typeof cb !== 'function') {
	        throw Error('illegal jsonp callback function:', cb)
	    }

	    var con = document.getElementsByTagName('head') ? document.getElementsByTagName('head')[0] : document.body
	    var s = document.createElement('script')
	    s.charset = 'UTF-8'
	    var cid = [options.ns || _ns, _id ++, uuid()].join('_')
	    var useTs = true // enable timestamp of not
	    var tsName = '_t' // 
	    var time = options.time

	    if (options.callbackid) {
	        cid = options.callbackid
	    }
	    if (time === false) {
	        useTs = false
	    } else if (time) {
	        tsName = time
	    }
	    /**
	     * JSONP owner params
	     */
	    data[options.pn || options.callbackName || _pn] = cid

	    if (useTs) {
	        data[tsName] = +new Date()
	    }

	    var onsuccess = function (data) {
	        remove(s)
	        cb(null, data)
	        resolve && resolve(data)
	    }
	    var onerror = function (e) {
	        remove(s)
	        cb(e || 'error')
	        window[cid] = onsuccess = onerror = noop
	        reject && reject(e || error)
	    }
	    var prehook = window[cid]
	    window[cid] = function (data) {
	        window[cid] = noop
	        try {
	            prehook && prehook(data)
	        } finally {
	            onsuccess(data)
	            onsuccess = onerror = noop
	        }
	    }
	    s.onerror = s.onabort = function (e) {
	        onerror(e ? e.type : 'error')
	    }

	    // hook can change url one by one
	    fns.forEach(_beforeHooks, function (fn) {
	        if (fns.type(fn) == 'function') {
	            url = fn(url, data) || url
	        }
	    })
	    s.src = TURL.queryJoin(url, data)
	    con.appendChild(s)
	    setTimeout(function () {
	        onerror('timeout')
	    }, options.timeout || _t)
	})}
	jsonp.timeout = function (t) {
	    _t = t
	}
	jsonp.ns = function (n) {
	    _ns = n
	}
	jsonp.pn = function (n) {
	    _pn = n
	}
	jsonp.before = function (fn) {
	    _beforeHooks.push(fn)
	}
	function PWrap(handler) {
	    if (window.Promise) return new Promise(handler)
	    else {
	        handler(noop, noop)
	    }
	}
	module.exports = jsonp

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict'

	var util = __webpack_require__(1)

	var url = {
	    /**
	     *  解析 query 字符串
	     **/
	    queryParse: function(search, spliter) {
	        if (!search) return {};

	        spliter = spliter || '&';

	        var query = search.replace(/^\?/, ''),
	            queries = {},
	            splits = query ? query.split(spliter) : null;

	        if (splits && splits.length > 0) {
	            util.forEach(splits, function(item) {
	                item = item.split('=');
	                var key = item.splice(0, 1),
	                    value = item.join('=');
	                queries[key] = value;
	            });
	        }
	        return queries;
	    },
	    /**
	     * URL添加query
	     */
	    queryJoin: function (api, queries) {
	        var qs = url.queryStringify(queries)
	        if (!qs) return api
	        
	        var sep
	        if (/[\?&]$/.test(api)) {
	            sep = ''
	        } else if (~api.indexOf('?')) {
	            sep = '&'
	        } else {
	            sep = '?'
	        }
	        return api + sep + qs
	    },
	    /**
	     * query 对象转换字符串
	     */
	    queryStringify: function (params, spliter) {
	        if (!params) return ''
	        return util.map(util.keys(params), function (k) {
	            return k + '=' + encodeURIComponent(params[k])
	        }).join(spliter || '&')
	    }
	}

	module.exports = url

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var consts = __webpack_require__(5)
	var jsonp = __webpack_require__(6)
	var fns = __webpack_require__(1)

	var MAX_PN=10       //分页拿取一次最多拿10条

	//list的可选组合：cid_vid或者_或者_和pn,cur的组合,cid_vid|cid_vid
	function getHistory(key, cb, options) {
	    var data,url;
	    if (key.length > 2) {
	        data = {
	            list:key
	        }
	        url=consts.api.specifyview
	    }else{
	        data={    //通过cgi去全量拉取数据,或者提供翻页和翻页条数
	          pn:0,
	          cur:0
	        }
	        url=consts.api.batchview     //cgi的URL
	        if(options.pn&&options.pn>MAX_PN){
	              options.pn=MAX_PN
	        }
	        data = fns.extend(data, options)
	    }
	    jsonp(url, data, function(err, res) {
	        if (err) {
	            cb(err)
	        } else if (res && res.result && res.result.code < 0) {
	            cb('请求失败')
	        } else {
	            res = res && res.list || []
	            res.length > 0 ? cb(null, res) :
	                cb('不存在' + key + "的历史记录")

	        }
	    })
	}
	//cid_vid|cid_vid
	// function batchHistory(keyidArr, cb) {
	//     var list = keyidArr.join('|')
	//     var data = {
	//         simp: 1,
	//         pver: 1,
	//         plat: 2,
	//         t: consts.rParamT.BATCHREQUESTINFO,
	//         list: list
	//     }
	//     jsonp(URL, data, function(err, res) {
	//         if (err) {
	//             cb(err)
	//         } else if (res && res.result && res.result.code < 0) {
	//             cb('请求失败')
	//         } else {
	//             res = res && res.list || []
	//             res.length > 0 ? cb(null, res) :
	//                 cb('不存在' + list + "的历史记录")
	//         }
	//     })
	// }

	module.exports = {
	    getHistory: getHistory
	}

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	module.exports = {
		by: function(attr) {
			return function(a, b) {
				var tempA = parseInt(a[attr])||0,
					tempB = parseInt(b[attr])||0;
				return tempA < tempB ? 1 : -1
			}
		}
	}

/***/ })
/******/ ]);